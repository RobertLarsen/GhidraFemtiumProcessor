define endian=little;
define alignment=4;

define space ram type=ram_space size=4 wordsize=4 default;
define space register type=register_space size=4;

define register offset=0 size=4 [
    zz
    v0 v1
    a0 a1 a2 a3 a4 a5 a6
    s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 s12 s13 s14 s15 s16 s17 s18 s19
    t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21
    xr yr zr
    k0 k1
    at0 at1
    ra fp gp sp pc
];

define token instr(32)
    opcode = (27, 31)
    r      = (21, 26)
    x      = (15, 20)
    y      = (9, 14)
    E      = (8, 8)
    o      = (0, 7)
    m      = (5, 8)
    s      = (0, 4)
    i      = (5, 20)
    c      = (0, 3)
    j      = (5, 14)
;

attach variables [ r x y ] [
    zz
    v0 v1
    a0 a1 a2 a3 a4 a5 a6
    s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 s12 s13 s14 s15 s16 s17 s18 s19
    t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21
    xr yr zr
    k0 k1
    at0 at1
    ra fp gp sp pc
];

##################################
# Memory load/store instructions #
##################################
:ldb r [x + y + o] is opcode=0b00000 & E=0 & r & x & y & o {
    local tgt = x + y + o;
    r = zext(*[ram]:1 tgt);
}
:ldbs r [x + y + o] is opcode=0b00000 & E=1 & r & x & y & o {
    local tgt = x + y + o;
    r = sext(*[ram]:1 tgt);
}
:ldh r [x + y + o] is opcode=0b00001 & E=0 & r & x & y & o {
    local tgt = x + y + o;
    r = zext(*[ram]:2 tgt);
}
:ldhs r [x + y + o] is opcode=0b00001 & E=1 & r & x & y & o {
    local tgt = x + y + o;
    r = sext(*[ram]:2 tgt);
}
:ldw r [x + y + o] is opcode=0b00010 & E=0 & r & x & y & o {
    local tgt = x + y + o;
    r = *[ram]:4 tgt;
}

:stb r [x + y + o] is opcode=0b00100 & E=0 & r & x & y & o {
    local tgt = x + y + o;
    *[ram]:1 tgt = r;
}
:sth r [x + y + o] is opcode=0b00101 & E=0 & r & x & y & o {
    local tgt = x + y + o;
    *[ram]:2 tgt = r;
}
:stw r [x + y + o] is opcode=0b00110 & E=0 & r & x & y & o {
    local tgt = x + y + o;
    *[ram]:4 tgt = r;
}

###########################
# Arithmetic instructions #
###########################
:add r, x, y, o is opcode=0b01000 & E=0 & r & x & y & o {
    r = x + y + o;
}
:mul r, x, y, o is opcode=0b01001 & E=0 & r & x & y & o {
    r = x * (y + o);
}
:div r, x, y, o is opcode=0b01010 & E=0 & r & x & y & o {
    r = x / (y + o);
}
:divi r, x, y, o is opcode=0b01010 & E=1 & r & x & y & o {
    r = x s/ (y + o);
}
:nor r, x, y, o is opcode=0b01011 & E=0 & r & x & y & o {
    r = ~(x | y | o);
}

#######################
# Masking instruction #
#######################
:shl r, x, y, s is opcode=0b01100 & m=0b0000 & r & x & y & s {
    r = x << (y + s);
}
:shr r, x, y, s is opcode=0b01100 & m=0b0001 & r & x & y & s {
    r = x >> (y + s);
}
:sar r, x, y, s is opcode=0b01100 & m=0b0010 & r & x & y & s {
    r = x s>> (y + s);
}
:shlo r, x, y, s is opcode=0b01100 & m=0b0100 & r & x & y & s {
    r = r | (x << (y + s));
}
:shro r, x, y, s is opcode=0b01100 & m=0b0101 & r & x & y & s {
    r = r | (x >> (y + s));
}
:saro r, x, y, s is opcode=0b01100 & m=0b0110 & r & x & y & s {
    r = r | (x s>> (y + s));
}
:shla r, x, y, s is opcode=0b01100 & m=0b1000 & r & x & y & s {
    r = r & (x << (y + s));
}
:shra r, x, y, s is opcode=0b01100 & m=0b1001 & r & x & y & s {
    r = r & (x >> (y + s));
}
:sara r, x, y, s is opcode=0b01100 & m=0b1010 & r & x & y & s {
    r = r & (x s>> (y + s));
}
:shlx r, x, y, s is opcode=0b01100 & m=0b1100 & r & x & y & s {
    r = r ^ (x << (y + s));
}
:shrx r, x, y, s is opcode=0b01100 & m=0b1101 & r & x & y & s {
    r = r ^ (x >> (y + s));
}
:sarx r, x, y, s is opcode=0b01100 & m=0b1110 & r & x & y & s {
    r = r ^ (x s>> (y + s));
}

####################
# Assign immediate #
####################
:movi r, i << s is opcode=0b10000 & r & i & s {
    r = i << s;
}
:addi r, i << s is opcode=0b10001 & r & i & s {
    r = r + (i << s);
}

##########################
# Conditional evaluation #
##########################

@define CMP_NZ  "0b0000"
@define CMP_LEU "0b0001"
@define CMP_LTU "0b0010"
@define CMP_EQ  "0b0011"
@define CMP_EZ  "0b0100"
@define CMP_GTU "0b0101"
@define CMP_GEU "0b0110"
@define CMP_NE  "0b0111"
@define CMP_LE  "0b1001"
@define CMP_LT  "0b1010"
@define CMP_GT  "0b1101"
@define CMP_GE  "0b1110"

macro compare(_op, _a, _b, _cmp_res) {
    if (!(_op == $(CMP_NZ))) goto <A>;
    _cmp_res = (_a != 0);
    goto <l>;
    <A>
    if (!(_op == $(CMP_LEU))) goto <B>;
    _cmp_res = (_a <= _b);
    goto <l>;
    <B>
    if (!(_op == $(CMP_LTU))) goto <C>;
    _cmp_res = (_a < _b);
    goto <l>;
    <C>
    if (!(_op == $(CMP_EQ))) goto <D>;
    _cmp_res = (_a == _b);
    goto <l>;
    <D>
    if (!(_op == $(CMP_EZ))) goto <e>;
    _cmp_res = (_a == 0);
    goto <l>;
    <e>
    if (!(_op == $(CMP_GTU))) goto <F>;
    _cmp_res = (_a > _b);
    goto <l>;
    <F>
    if (!(_op == $(CMP_GEU))) goto <G>;
    _cmp_res = (_a >= _b);
    goto <l>;
    <G>
    if (!(_op == $(CMP_NE))) goto <h>;
    _cmp_res = (_a != _b);
    goto <l>;
    <h>
    if (!(_op == $(CMP_LE))) goto <I>;
    _cmp_res = (_a s<= _b);
    goto <l>;
    <I>
    if (!(_op == $(CMP_LT))) goto <J>;
    _cmp_res = (_a s< _b);
    goto <l>;
    <J>
    if (!(_op == $(CMP_GT))) goto <k>;
    _cmp_res = (_a s> _b);
    goto <l>;
    <k>
    if (!(_op == $(CMP_GE))) goto <l>;
    _cmp_res = (_a s>= _b);
    <l>
}

####################
# Conditional move #
####################
:cmnz r, x is opcode=0b10010 & c=$(CMP_NZ) & r & x & y {
    if (!(x != 0)) goto <skip>;
    r = x;
    <skip>
}
:cmleu r, x, y is opcode=0b10010 & c=$(CMP_LEU) & r & x & y {
    if (!(x <= y)) goto <skip>;
    r = x;
    <skip>
}
:cmltu r, x, y is opcode=0b10010 & c=$(CMP_LTU) & r & x & y {
    if (!(x < y)) goto <skip>;
    r = x;
    <skip>
}
:cmeq r, x, y is opcode=0b10010 & c=$(CMP_EQ) & r & x & y {
    if (!(x == y)) goto <skip>;
    r = x;
    <skip>
}
:cmez r, x is opcode=0b10010 & c=$(CMP_EZ) & r & x {
    if (!(x == 0)) goto <skip>;
    r = x;
    <skip>
}
:cmgtu r, x, y is opcode=0b10010 & c=$(CMP_GTU) & r & x & y {
    if (!(x > y)) goto <skip>;
    r = x;
    <skip>
}
:cmgeu r, x, y is opcode=0b10010 & c=$(CMP_GEU) & r & x & y {
    if (!(x >= y)) goto <skip>;
    r = x;
    <skip>
}
:cmne r, x, y is opcode=0b10010 & c=$(CMP_NE) & r & x & y {
    if (!(x != y)) goto <skip>;
    r = x;
    <skip>
}
:cmle r, x, y is opcode=0b10010 & c=$(CMP_LE) & r & x & y {
    if (!(x s<= y)) goto <skip>;
    r = x;
    <skip>
}
:cmlt r, x, y is opcode=0b10010 & c=$(CMP_LT) & r & x & y {
    if (!(x s< y)) goto <skip>;
    r = x;
    <skip>
}
:cmgt r, x, y is opcode=0b10010 & c=$(CMP_GT) & r & x & y {
    if (!(x s> y)) goto <skip>;
    r = x;
    <skip>
}
:cmge r, x, y is opcode=0b10010 & c=$(CMP_GE) & r & x & y {
    if (!(x s>= y)) goto <skip>;
    r = x;
    <skip>
}

########################
# Compare instructions #
########################
:snz r, x is opcode=0b10111 & c=$(CMP_NZ) & r & x & y {
    r = 0;
    if (!(x != 0)) goto <skip>;
    r = 1;
    <skip>
}
:sleu r, x, y is opcode=0b10111 & c=$(CMP_LEU) & r & x & y {
    r = 0;
    if (!(x <= y)) goto <skip>;
    r = 1;
    <skip>
}
:sltu r, x, y is opcode=0b10111 & c=$(CMP_LTU) & r & x & y {
    r = 0;
    if (!(x < y)) goto <skip>;
    r = 1;
    <skip>
}
:seq r, x, y is opcode=0b10111 & c=$(CMP_EQ) & r & x & y {
    r = 0;
    if (!(x == y)) goto <skip>;
    r = 1;
    <skip>
}
:sez r, x is opcode=0b10111 & c=$(CMP_EZ) & r & x {
    r = 0;
    if (!(x == 0)) goto <skip>;
    r = 1;
    <skip>
}
:sgtu r, x, y is opcode=0b10111 & c=$(CMP_GTU) & r & x & y {
    r = 0;
    if (!(x > y)) goto <skip>;
    r = 1;
    <skip>
}
:sgeu r, x, y is opcode=0b10111 & c=$(CMP_GEU) & r & x & y {
    r = 0;
    if (!(x >= y)) goto <skip>;
    r = 1;
    <skip>
}
:sne r, x, y is opcode=0b10111 & c=$(CMP_NE) & r & x & y {
    r = 0;
    if (!(x != y)) goto <skip>;
    r = 1;
    <skip>
}
:sle r, x, y is opcode=0b10111 & c=$(CMP_LE) & r & x & y {
    r = 0;
    if (!(x s<= y)) goto <skip>;
    r = 1;
    <skip>
}
:slt r, x, y is opcode=0b10111 & c=$(CMP_LT) & r & x & y {
    r = 0;
    if (!(x s< y)) goto <skip>;
    r = 1;
    <skip>
}
:sgt r, x, y is opcode=0b10111 & c=$(CMP_GT) & r & x & y {
    r = 0;
    if (!(x s> y)) goto <skip>;
    r = 1;
    <skip>
}
:sge r, x, y is opcode=0b10111 & c=$(CMP_GE) & r & x & y {
    r = 0;
    if (!(x s>= y)) goto <skip>;
    r = 1;
    <skip>
}
